//! ğŸ¯å¤åˆ»OpenNARS `nars.inference.CompositionalRules`
//!
//! * âœ…ã€2024-05-12 00:47:43ã€‘åˆæ­¥å¤ç°æ–¹æ³•API
//! * â™»ï¸ã€2024-08-05 17:31:37ã€‘å¼€å§‹æ ¹æ®æ”¹ç‰ˆOpenNARSé‡å†™

use super::SyllogismPosition;
use crate::{
    control::*,
    entity::*,
    inference::{rules::utils::*, *},
    io::symbols::*,
    language::*,
    util::RefCount,
};
use nar_dev_utils::unwrap_or_return;
use ReasonDirection::*;
use SyllogismPosition::*;

/* -------------------- intersections and differences -------------------- */

/// ğŸ†•ä½œä¸ºã€Œé›†åˆã€æ“ä½œï¼šäº¤å¹¶å·®
pub fn compose_as_set(
    task_content: StatementRef,
    shared_term_i: SyllogismPosition,
    component_common: &Term,
    component_t: &Term,
    component_b: &Term,
    context: &mut ReasonContextConcept,
) {
    // * ğŸš©æ ¹æ®ã€Œå…±æœ‰è¯é¡¹çš„ä½ç½®ã€åˆ†æ´¾
    // * ğŸš©å…±æœ‰åœ¨ä¸»é¡¹ â‡’ å†…æ¶µäº¤ï¼Œå¤–å»¶äº¤ï¼Œå¤–å»¶å·®
    // * ğŸ“„"<M ==> S>", "<M ==> P>"
    // * ğŸš©ã€Œæˆ–ã€å†…æ¶µäº¤
    // * ğŸš©ã€Œä¸ã€å¤–å»¶äº¤
    // * ğŸš©æ ¹æ®ã€ŒçœŸå€¼æ˜¯å¦è´Ÿé¢ã€å†³å®šã€Œå·®ã€çš„çœŸå€¼
    // * ğŸš©åŒæ­£/åŒè´Ÿ â‡’ ä¸äºˆç”Ÿæˆ
    // * ğŸš©ä»»åŠ¡æ­£ï¼Œä¿¡å¿µè´Ÿ â‡’ è¯é¡¹="(ä»»åŠ¡-ä¿¡å¿µ)"ï¼ŒçœŸå€¼=ä»»åŠ¡ âˆ© Â¬ä¿¡å¿µ
    // * ğŸš©ä»»åŠ¡è´Ÿï¼Œä¿¡å¿µæ­£ â‡’ è¯é¡¹="(ä¿¡å¿µ-ä»»åŠ¡)"ï¼ŒçœŸå€¼=ä¿¡å¿µ âˆ© Â¬ä»»åŠ¡
    // * ğŸš©å…¶å®ƒâ‡’ä¸å¯è¾¾
    // * ğŸš©ç»Ÿä¸€å¯¼å‡ºç»“è®ºï¼š"<å…¬å…±é¡¹ ==> æ–°è¯é¡¹>"
    // index == 1
    // * ğŸš©å…±æœ‰åœ¨è°“é¡¹ â‡’ å†…æ¶µäº¤ï¼Œå¤–å»¶äº¤ï¼Œå†…æ¶µå·®
    // * ğŸ“„"<S ==> M>", "<P ==> M>"
    // * ğŸš©ã€Œæˆ–ã€å¤–å»¶äº¤
    // * ğŸš©ã€Œä¸ã€å†…æ¶µäº¤
    // * ğŸš©æ ¹æ®ã€ŒçœŸå€¼æ˜¯å¦è´Ÿé¢ã€å†³å®šã€Œå·®ã€çš„çœŸå€¼
    // * ğŸš©åŒæ­£/åŒè´Ÿ â‡’ ä¸äºˆç”Ÿæˆ
    // * ğŸš©ä»»åŠ¡æ­£ï¼Œä¿¡å¿µè´Ÿ â‡’ è¯é¡¹="(ä»»åŠ¡-ä¿¡å¿µ)"ï¼ŒçœŸå€¼=ä»»åŠ¡ âˆ© Â¬ä¿¡å¿µ
    // * ğŸš©ä»»åŠ¡è´Ÿï¼Œä¿¡å¿µæ­£ â‡’ è¯é¡¹="(ä¿¡å¿µ-ä»»åŠ¡)"ï¼ŒçœŸå€¼=ä¿¡å¿µ âˆ© Â¬ä»»åŠ¡
    // * ğŸš©å…¶å®ƒâ‡’ä¸å¯è¾¾
    // * ğŸš©ç»Ÿä¸€å¯¼å‡ºç»“è®ºï¼š"<æ–°è¯é¡¹ ==> å…¬å…±é¡¹>"
}

/// * ğŸ“Œæ ¹æ®ä¸»è°“é¡¹ã€çœŸå€¼ åˆ›å»ºæ–°å†…å®¹ï¼Œå¹¶å¯¼å‡ºç»“è®º
///
/// # ğŸ“„OpenNARS
///
/// Finish composing implication term
fn process_composed(
    task_content: Statement,
    subject: Term,
    predicate: Term,
    truth: TruthValue,
    context: &mut ReasonContextConcept,
) {
    // * ğŸš©è·³è¿‡ç©ºå€¼
    // * ğŸš©è¯é¡¹ï¼šä¸èƒ½è·Ÿä»»åŠ¡ã€ä¿¡å¿µ å†…å®¹ç›¸åŒ
    // ! å‡å®šä¸€å®šæœ‰ã€Œå½“å‰ä¿¡å¿µã€
    // * ğŸš©é¢„ç®—ï¼šå¤åˆå‰å‘
    // * ğŸš©ç»“è®º
}

/// # ğŸ“„OpenNARS
///
/// ```nal
/// {<(S|P) ==> M>, <P ==> M>} |- <S ==> M>
/// ```
pub fn decompose_compound(
    compound: CompoundTermRef,
    component: &Term,
    component_common: &Term,
    side: SyllogismPosition,
    compound_from: PremiseSource,
    context: &mut ReasonContextConcept,
) {
    // * ğŸš©ã€Œå‚è€ƒçš„å¤åˆè¯é¡¹ã€æ˜¯ é™ˆè¿°/åƒ â‡’ ä¸è§£æ„
    // * ğŸš©å°†å½“å‰å…ƒç´ ä»å¤åˆè¯é¡¹ä¸­ç§»é™¤
    // * ğŸš©è¯é¡¹ * //
    // * ğŸš©å…±æœ‰å‰é¡¹
    // * ğŸš©å…±æœ‰åé¡¹
    // * ğŸš©çœŸå€¼ * //
    // ! åªèƒ½æ˜¯åˆ¤æ–­å¥ã€æ­£å‘æ¨ç†
    // * ğŸš©æ ¹æ®å„è¯é¡¹ç±»å‹åˆ†æ´¾
    // * ğŸš©å…±ç”¨ä¸»é¡¹
    // * ğŸš©æ—§ä»»åŠ¡å†…å®¹ <: ç»§æ‰¿
    // * ğŸš©å¤–å»¶äº¤ â‡’ åˆå–
    // * ğŸš©å†…æ¶µäº¤ â‡’ æå–
    // * ğŸš©å†…æ¶µé›†-å†…æ¶µé›† â‡’ åˆå–
    // * ğŸš©å¤–å»¶é›†-å¤–å»¶é›† â‡’ æå–
    // * ğŸš©å¤–å»¶å·®
    // * ğŸš©å†…å®¹æ­£å¥½ä¸ºè¢«å‡é¡¹ â‡’ æå–ï¼ˆåå‘ï¼‰
    // * ğŸš©å…¶å®ƒ â‡’ åˆå–å¦å®š
    // * ğŸš©å…¶å®ƒ â‡’ å¦å†³
    // * ğŸš©æ—§ä»»åŠ¡å†…å®¹ <: è•´å«
    // * ğŸš©åˆå– â‡’ åˆå–
    // * ğŸš©æå– â‡’ æå–
    // * ğŸš©å…¶å®ƒ â‡’ å¦å†³
    // * ğŸš©å…¶å®ƒ â‡’ å¦å†³
    // * ğŸš©å…±ç”¨è°“é¡¹
    // * ğŸš©æ—§ä»»åŠ¡å†…å®¹ <: ç»§æ‰¿
    // * ğŸš©å†…æ¶µäº¤ â‡’ åˆå–
    // * ğŸš©å¤–å»¶äº¤ â‡’ æå–
    // * ğŸš©å¤–å»¶é›†-å¤–å»¶é›† â‡’ åˆå–
    // * ğŸš©å†…æ¶µé›†-å†…æ¶µé›† â‡’ æå–
    // * ğŸš©å†…æ¶µå·®
    // * ğŸš©å†…å®¹æ­£å¥½ä¸ºæ‰€å‡é¡¹ â‡’ æå–ï¼ˆåå‘ï¼‰
    // * ğŸš©å…¶å®ƒ â‡’ åˆå–å¦å®š
    // * ğŸš©æ—§ä»»åŠ¡å†…å®¹ <: è•´å«
    // * ğŸš©å…¶å®ƒ â‡’ å¦å†³
    // * ğŸš©å…¶å®ƒ â‡’ å¦å†³
    // * ğŸš©é¢„ç®— * //
    // * ğŸš©ç»“è®º * //
}

/// # ğŸ“„OpenNARS
///
/// ```nal
/// {(||, S, P), P} |- S
// {(&&, S, P), P} |- S
/// ```
pub fn decompose_statement(
    compound: CompoundTermRef,
    component: &Term,
    compound_from: PremiseSource,
    context: &mut ReasonContextConcept,
) {
    // * ğŸš©åˆ å»æŒ‡å®šçš„é‚£ä¸ªå…ƒç´ ï¼Œç”¨åˆ å»ä¹‹åçš„å‰©ä½™å…ƒç´ åšç»“è®º
    // * ğŸš©åå‘æ¨ç†ï¼šå°è¯•ç­”é—®
    // * ğŸ“„(||,A,B)? + A. => B?
    // * ğŸš©å…ˆå°†å‰©ä½™éƒ¨åˆ†ä½œä¸ºã€Œé—®é¢˜ã€æå‡º
    // ! ğŸ“„åŸç‰ˆbugï¼šå½“è¾“å…¥ (||,A,?1)? æ—¶ï¼Œå› ã€Œå¼¹å‡ºçš„å˜é‡å¤æ‚åº¦ä¸ºé›¶ã€é¢„ç®—æ¨ç†ã€Œé™¤ä»¥é›¶ã€çˆ†ç‚¸
    // * ğŸš©å†å°†å¯¹åº”æœ‰ã€Œæ¦‚å¿µã€ä¸ã€Œä¿¡å¿µã€çš„å†…å®¹ä½œä¸ºæ–°çš„ã€Œä¿¡å¿µã€æ”¾å‡º
    // special inference to answer conjunctive questions with query variables
    // * ğŸš©åªæœ‰åœ¨ã€Œå›ç­”åˆå–é—®é¢˜ã€æ—¶ï¼Œå–å‡ºå…¶ä¸­çš„é¡¹æ„å»ºæ–°ä»»åŠ¡
    // * ğŸš©åªåœ¨ã€Œå†…å®¹å¯¹åº”äº†æ¦‚å¿µã€æ—¶ï¼Œå–å‡ºã€Œæ¦‚å¿µã€ä¸­çš„ä¿¡å¿µ
    // * ğŸš©åªåœ¨ã€Œæ¦‚å¿µä¸­æœ‰ä¿¡å¿µã€æ—¶ï¼Œä»¥è¿™ä¸ªä¿¡å¿µä½œä¸ºã€Œå½“å‰ä¿¡å¿µã€æ„å»ºæ–°ä»»åŠ¡
    // * ğŸš©å®é™…ä¸Šå°±æ˜¯éœ€è¦ä¸ã€Œå·²æœ‰ä¿¡å¿µã€çš„è¯æ®åŸºåˆå¹¶
    // * ğŸš©ã€2024-06-07 13:41:16ã€‘ç°åœ¨ç›´æ¥ä»ã€Œä»»åŠ¡ã€æ„é€ æ–°çš„ã€Œé¢„ç®—å€¼ã€
    // ! ğŸš©ã€2024-05-19 20:29:17ã€‘ç°åœ¨ç§»é™¤ï¼šç›´æ¥åœ¨ã€Œå¯¼å‡ºç»“è®ºã€å¤„æŒ‡å®š
    // * â†“ä¸ä¼šç”¨åˆ°`context.getCurrentTask()`ã€`newStamp`
    // * â†“ä¸ä¼šç”¨åˆ°`context.getCurrentTask()`ã€`newStamp`
    // ! âš ï¸â†“ä¼šç”¨åˆ°`context.getCurrentTask()`ã€`newStamp`ï¼šæ„å»ºæ–°ç»“è®ºæ—¶è¦ç”¨åˆ°
    // * âœ…ã€2024-05-21 22:38:52ã€‘ç°åœ¨é€šè¿‡ã€Œå‚æ•°ä¼ é€’ã€æŠµæ¶ˆäº†å¯¹`context.getCurrentTask`çš„è®¿é—®
    // * ğŸš©å‰å‘æ¨ç†ï¼šç›´æ¥ç”¨äºæ„é€ ä¿¡å¿µ
    // * ğŸš©é€‰å–å‰æçœŸå€¼ | âš ï¸å‰åä»¶è¯­ä¹‰ä¸åŒ
    // * ğŸš©é€‰å–çœŸå€¼å‡½æ•°
    // * ğŸš©æ„é€ çœŸå€¼ã€é¢„ç®—å€¼ï¼ŒåŒå‰æç»“è®º
}

/* --------------- rules used for variable introduction --------------- */

/// ğŸ†•å…¥å£ä¹‹ä¸€ï¼šå˜é‡å¼•å…¥
/// ! âš ï¸ã€2024-07-23 12:20:18ã€‘é€»è¾‘æœªå®Œå…¨è¢«æµ‹è¯•è¦†ç›–ï¼Œä»£ç ç†è§£åº¦ä½
/// * ğŸ“ã€2024-07-23 12:04:33ã€‘OpenNARS 3.1.0ä»ç„¶æ²¡æœ‰æ ·ä¾‹æ³¨é‡Šâ€¦â€¦
/// * ğŸ“„ä¸€ä¾‹ï¼ˆå¹³å‡¡æƒ…å†µï¼‰ï¼š
///   * originalMainSentence = "<<$1 --> swimmer> ==> <$1 --> bird>>"
///   * subSentence = "<bird --> animal>"
///   * component = "<$1 --> bird>"
///   * subContent = "<bird --> animal>"
///   * index = 1 @ originalMainSentence
///   * => "<<$1 --> swimmer> ==> <$1 --> bird>>"
pub fn intro_var_same_subject_or_predicate(
    original_main_sentence: &impl Judgement,
    sub_sentence: &impl Judgement,
    component: &Term,
    sub_content: CompoundTermRef,
    side: SyllogismPosition,
    context: &mut ReasonContextConcept,
) {
    // * ğŸš©è¯é¡¹ * //
    // * ğŸš©ä»…å¯¹å¤åˆè¯é¡¹
    // * ğŸš©å¯¹å†…éƒ¨å†…å®¹ï¼Œä»…é€‚ç”¨äºã€Œç»§æ‰¿Ã—ç»§æ‰¿ã€ä¸ã€Œç›¸ä¼¼Ã—ç›¸ä¼¼ã€
    // CompoundTerm result = mainCompound;
    // wouldn't make sense to create a conjunction here,
    // would contain a statement twice
    // ! âš ï¸ã€2024-07-23 12:17:44ã€‘ç›®å‰è¿˜æ²¡çœŸæ­£è§¦å‘è¿‡æ­¤å¤„é€»è¾‘
    // ! * è¯¸å¤šå°è¯•å‡è¢«ã€Œå˜é‡åˆ†ç¦»è§„åˆ™ã€ç­‰ æˆªèƒ¡
    // * âœ…ä¸æ€•é‡åï¼šç°åœ¨å§‹ç»ˆæ˜¯ã€Œæœ€å¤§è¯é¡¹çš„æœ€å¤§id+1ã€çš„æ¨¡å¼
    // ! âš ï¸ã€2024-07-23 12:17:44ã€‘ç›®å‰è¿˜æ²¡çœŸæ­£è§¦å‘è¿‡æ­¤å¤„é€»è¾‘
    // ! * è¯¸å¤šå°è¯•å‡è¢«ã€Œå˜é‡åˆ†ç¦»è§„åˆ™ã€ç­‰ æˆªèƒ¡
    /*
     * ğŸ“„å·²çŸ¥å¦‚ä¸‹è¾“å…¥æ— æ³•è§¦å‘ï¼š
     * <swam --> swimmer>.
     * <swam --> bird>.
     * <bird --> swimmer>.
     * <<$1 --> swimmer> ==> <$1 --> bird>>.
     * <<bird --> $1> ==> <swimmer --> $1>>.
     * 1000
     */
    // * âœ…ä¸æ€•é‡åï¼šç°åœ¨å§‹ç»ˆæ˜¯ã€Œæœ€å¤§è¯é¡¹çš„æœ€å¤§id+1ã€çš„æ¨¡å¼
    // ? ã€2024-07-23 12:20:27ã€‘ä¸ºä½•è¦é‡å¤å¾—å‡ºç»“æœ
    // * ğŸš©çœŸå€¼ * //
    // * ğŸš©é¢„ç®— * //
    // * ğŸš©ç»“è®º * //
}

/// Introduce a dependent variable in an outer-layer conjunction
/// * ğŸ“ã€Œå˜é‡å¤–å¼•å…¥ã€ç³»åˆ—è§„åˆ™
///
/// * ğŸ“Œå¯¼å‡ºç»“è®ºï¼šã€Œæ­£åä¼¼åˆã€
///   * å¤–å»¶æ­£ä¼ é€’ï¼ˆå½’å› /å½’çº³ï¼‰
///   * å¤–å»¶åä¼ é€’ï¼ˆå½’å› /å½’çº³ï¼‰
///   * ç›¸ä¼¼ã®ä¼ é€’ï¼ˆæ¯”è¾ƒï¼‰
///   * å› å˜é‡å¼•å…¥ï¼ˆåˆå–ï¼‰
///
/// * ğŸ“„@ä¸»é¡¹: "<M --> S>" Ã— "<M --> P>"
///   * => "<<$1 --> S> ==> <$1 --> P>>"
///   * => "<<$1 --> P> ==> <$1 --> S>>"
///   * => "<<$1 --> S> <=> <$1 --> P>>"
///   * => "(&&,<#1 --> S>,<#1 --> P>)"
///
/// * ğŸ“„@è°“é¡¹: "<S --> M>" Ã— "<P --> M>"
///   * => "<<S --> $1> ==> <P --> $1>>"
///   * => "<<P --> $1> ==> <S --> $1>>"
///   * => "<<P --> $1> <=> <S --> $1>>"
///   * => "(&&,<P --> #1>,<S --> #1>)"
pub fn intro_var_outer(
    task_content: StatementRef,
    belief_content: StatementRef,
    shared_term_i: SyllogismPosition,
    context: &mut ReasonContextConcept,
) {
    // * ğŸš©ä»»åŠ¡/ä¿¡å¿µ çš„çœŸå€¼ | ä»…é€‚ç”¨äºå‰å‘æ¨ç†
    // * ğŸš©è¯é¡¹åˆæ­¥ï¼šå¼•å…¥å˜é‡ * //
    // * ğŸš©ç»§ç»­åˆ†æ´¾ï¼šè¯é¡¹ã€çœŸå€¼ã€é¢„ç®—ã€ç»“è®º * //
}

/// ğŸ†•ä»¥ã€Œå˜é‡å¤–å¼•å…¥ã€çš„å†…éƒ¨è¯é¡¹ï¼Œè®¡ç®—ã€Œå¼•å…¥çŠ¶æ€ã€é™ˆè¿°
/// * ğŸ“Œå¼•å…¥çš„æ˜¯ã€Œç‹¬ç«‹å˜é‡/è‡ªå˜é‡ã€"$"
/// * ğŸ¯äº§ç”Ÿçš„é™ˆè¿°ï¼ˆäºŒå…ƒç»„ï¼‰ç”¨äºç”Ÿæˆæ–°ç»“è®ºå†…å®¹
fn intro_var_states_ind(
    task_content: Statement,
    belief_content: Statement,
    side: SyllogismPosition,
) -> [Term; 2] {
    // * ğŸš©æ ¹æ®ç´¢å¼•å†³å®šã€Œè¦ç»„æˆæ–°é™ˆè¿°çš„è¯é¡¹çš„ä½ç½®ã€
    // index == 1
    // * ğŸš©å¯»æ‰¾ã€Œç¬¬äºŒä¸ªç›¸åŒè¯é¡¹ã€å¹¶åœ¨å†…å®¹ä¸­æ›¿æ¢ | å¯¹ã€Œå¤–å»¶åƒ@0ã€ã€Œå†…æ¶µåƒ@1ã€çš„ç‰¹æ®Šå¤„ç†
    // * ğŸ“Œã€2024-07-23 13:19:30ã€‘æ­¤å¤„åŸç ä¸secondCommonTermç›¸åŒï¼Œæ•…æå–ç®€å¹¶
    // * ğŸš©äº§ç”Ÿä¸€ä¸ªæ–°çš„ç‹¬ç«‹å˜é‡ï¼Œå¹¶ä»¥æ­¤æ›¿æ¢
    // ! âš ï¸åœ¨æ­¤æœŸé—´ã€ä¿®æ”¹ã€‘å…¶ã€æ‰€æŒ‡å‘ã€‘çš„è¯é¡¹
    // * ğŸš©è¿”å›ï¼šä»å…ƒç´ æ„é€ ç»§æ‰¿é™ˆè¿°
    todo!()
}

/// ğŸ†•ä»¥ã€Œå˜é‡å¤–å¼•å…¥ã€çš„å†…éƒ¨è¯é¡¹ï¼Œè®¡ç®—ã€Œå¼•å…¥çŠ¶æ€ã€é™ˆè¿°
/// * ğŸ“Œå¼•å…¥çš„æ˜¯ã€Œç‹¬ç«‹å˜é‡/è‡ªå˜é‡ã€"$"
/// * ğŸ¯äº§ç”Ÿçš„é™ˆè¿°ï¼ˆäºŒå…ƒç»„ï¼‰ç”¨äºç”Ÿæˆæ–°ç»“è®ºå†…å®¹
fn intro_var_states_dep(
    task_content: Statement,
    belief_content: Statement,
    side: SyllogismPosition,
) -> [Term; 2] {
    todo!()
}

/// ã€Œå˜é‡å¤–å¼•å…¥ã€è§„åˆ™ ç»“è®º1
/// * ğŸ“„"<bird --> animal>" Ã— "<bird --> swimmer>"
///   * => "<<$1 --> animal> ==> <$1 --> swimmer>>"
/// * ğŸ“„"<sport --> competition>" Ã— "<chess --> competition>"
///   * => "<<sport --> $1> ==> <chess --> $1>>"
fn intro_var_outer1(
    state_1: Term,
    state_2: Term,
    truth_t: &impl Truth,
    truth_b: &impl Truth,
    context: &mut ReasonContextConcept,
) {
    // TODO
}

/// ã€Œå˜é‡å¤–å¼•å…¥ã€è§„åˆ™ ç»“è®º2
/// * ğŸ“„"<bird --> animal>" Ã— "<bird --> swimmer>"
///   * => "<<$1 --> swimmer> ==> <$1 --> animal>>"
/// * ğŸ“„"<sport --> competition>" Ã— "<chess --> competition>"
///   * => "<<chess --> $1> ==> <sport --> $1>>"
fn intro_var_outer2(
    state_1: Term,
    state_2: Term,
    truth_t: &impl Truth,
    truth_b: &impl Truth,
    context: &mut ReasonContextConcept,
) {
    // TODO
}

/// ã€Œå˜é‡å¤–å¼•å…¥ã€è§„åˆ™ ç»“è®º3
/// * ğŸ“„"<bird --> animal>" Ã— "<bird --> swimmer>"
///   * => "<<$1 --> animal> <=> <$1 --> swimmer>>"
/// * ğŸ“„"<sport --> competition>" Ã— "<chess --> competition>"
///   * => "<<chess --> $1> <=> <sport --> $1>>"
fn intro_var_outer3(
    state_1: Term,
    state_2: Term,
    truth_t: &impl Truth,
    truth_b: &impl Truth,
    context: &mut ReasonContextConcept,
) {
    // TODO
}

/// ã€Œå˜é‡å¤–å¼•å…¥ã€è§„åˆ™ ç»“è®º4
/// * ğŸ“„"<bird --> animal>" Ã— "<bird --> swimmer>"
///   * => "(&&,<#1 --> animal>,<#1 --> swimmer>)"
/// * ğŸ“„"<sport --> competition>" Ã— "<chess --> competition>"
///   * => "(&&,<chess --> #1>,<sport --> #1>)"
fn intro_var_outer4(
    state_1: Term,
    state_2: Term,
    truth_t: &impl Truth,
    truth_b: &impl Truth,
    context: &mut ReasonContextConcept,
) {
    // TODO
}

/// * ğŸ“å…¥å£2ï¼šå˜é‡å†…å¼•å…¥
///
/// # ğŸ“„OpenNARS
///
/// ```nal
/// {<M --> S>, <C ==> <M --> P>>} |- <(&&, <#x --> S>, C) ==> <#x --> P>>
/// {<M --> S>, (&&, C, <M --> P>)} |- (&&, C, <<#x --> S> ==> <#x --> P>>)
/// ```
pub fn intro_var_inner(
    premise_1: StatementRef,
    premise_2: StatementRef,
    old_compound: CompoundTermRef,
    context: &mut ReasonContextConcept,
) {
    // * ğŸš©ä»…é€‚ç”¨äºå‰å‘æ¨ç†
    // * ğŸš©å‰æ1ä¸å‰æ2å¿…é¡»æ˜¯ç›¸åŒç±»å‹ï¼Œä¸”ã€Œæ—§å¤åˆè¯é¡¹ã€ä¸èƒ½åŒ…æ‹¬å‰æ1
    // * ğŸš©è®¡ç®—å…±æœ‰è¯é¡¹
    // * ğŸš©ç»§ç»­å‘ä¸‹åˆ†æ´¾
}

/// ğŸ†•ä»¥ã€Œå˜é‡å†…å¼•å…¥ã€çš„å†…éƒ¨è¯é¡¹ï¼Œè®¡ç®—ã€Œå…±æœ‰è¯é¡¹ã€
/// * ğŸ¯äº§ç”Ÿçš„è¯é¡¹ï¼ˆäºŒå…ƒç»„/ç©ºï¼‰ç”¨äºç”Ÿæˆæ–°ç»“è®ºå†…å®¹
fn intro_var_commons(premise_1: Statement, premise_2: Statement) -> [Term; 2] {
    // * ğŸš©è½®æµåˆ¤ç­‰ä»¥å†³å®šæ‰€æŠ½å–çš„è¯é¡¹
    // * ğŸš©å…±æœ‰ä¸»é¡¹ â‡’ 11â†’(12Ã—22)
    // * ğŸš©å…±æœ‰è°“é¡¹ â‡’ 12â†’(11Ã—21)
    // * ğŸš©æ— å…±æœ‰è¯é¡¹â‡’ç©º
    todo!()
}

/// ã€Œå˜é‡å†…å¼•å…¥ã€è§„åˆ™ ç»“è®º1
/// * ğŸ“å¼•å…¥ç¬¬äºŒä¸ªå˜é‡ï¼Œå¹¶åœ¨æ›¿æ¢åäº§ç”Ÿä¸€ä¸ªåˆå–
///
/// * ğŸ“„"<{lock1} --> lock>" Ã— "<{lock1} --> (/,open,$1,_)>"
/// * * @ "<<$1 --> key> ==> <{lock1} --> (/,open,$1,_)>>"
/// * * => "(&&,<#2 --> lock>,<<$1 --> key> ==> <#2 --> (/,open,$1,_)>>)"
///
/// * ğŸ“„"<{Tweety} --> [chirping]>" Ã— "<robin --> [chirping]>"
/// * * @ "(&&,<robin --> [chirping]>,<robin --> [with_wings]>)"
/// * * => "(&&,<robin --> #1>,<robin --> [with_wings]>,<{Tweety} --> #1>)"
fn intro_var_inner1(
    premise_1: Statement,
    old_compound: CompoundTerm,
    truth_t: &impl Truth,
    truth_b: &impl Truth,
    common_term_1: Term,
    common_term_2: Term,
    context: &mut ReasonContextConcept,
) {
    // * ğŸš©è¯é¡¹ * //
    // * ğŸš©å°†ã€Œå…±æœ‰è¯é¡¹ã€æ›¿æ¢æˆå˜é‡
    // * ğŸš©çœŸå€¼ * //
    // * ğŸš©é¢„ç®— * //
    // * ğŸš©ç»“è®º * //
}

/// ã€Œå˜é‡å†…å¼•å…¥ã€è§„åˆ™ ç»“è®º2
/// * ğŸ“å¼•å…¥ç¬¬äºŒä¸ªå˜é‡ï¼Œå¹¶åœ¨æ›¿æ¢åäº§ç”Ÿä¸€ä¸ªè•´å«
///
/// * ğŸ“„"<{lock1} --> lock>" Ã— "<{lock1} --> (/,open,$1,_)>"
/// * * @ "<<$1 --> key> ==> <{lock1} --> (/,open,$1,_)>>"
/// * * => "<(&&,<$1 --> key>,<$2 --> lock>) ==> <$2 --> (/,open,$1,_)>>"
///
/// * ğŸ“„"<{Tweety} --> [chirping]>" Ã— "<robin --> [chirping]>"
/// * * @ "(&&,<robin --> [chirping]>,<robin --> [with_wings]>)"
/// * * => "<<{Tweety} --> $1> ==> (&&,<robin --> $1>,<robin --> [with_wings]>)>"
fn intro_var_inner2(
    premise_1: Statement,
    old_compound: CompoundTerm,
    truth_t: &impl Truth,
    truth_b: &impl Truth,
    common_term_1: Term,
    common_term_2: Term,
    context: &mut ReasonContextConcept,
) {
    // * ğŸš©è¯é¡¹ * //
    // * ğŸš©å°†ã€Œå…±æœ‰è¯é¡¹ã€æ›¿æ¢æˆå˜é‡
    // * ğŸš©çœŸå€¼ * //
    // * ğŸš©å‰æ == ä»»åŠ¡ â‡’ å½’çº³ ä¿¡å¿µâ†’ä»»åŠ¡
    // * ğŸš©å‰æ != ä»»åŠ¡ â‡’ å½’çº³ ä»»åŠ¡â†’ä¿¡å¿µ
    // * ğŸš©é¢„ç®— * //
    // * ğŸš©ç»“è®º * //
}

/// # ğŸ“„OpenNARS
///
/// Introduce a second independent variable into two terms with a common
/// component
fn second_common_term([term1, term2]: [&Term; 2], side: SyllogismPosition) -> &Term {
    // * ğŸ“„1: éƒ½æ˜¯ä¸»é¡¹ï¼Œä¸”å‡ä¸ºå¤–å»¶åƒ
    // * ğŸ“„2: éƒ½æ˜¯è°“é¡¹ï¼Œä¸”å‡ä¸ºå†…æ¶µåƒ
    // * ğŸš©å…ˆè¯•ç¬¬ä¸€ä¸ª
    // * ğŸš©å°è¯•ä¸åˆ°ï¼Ÿè€ƒè™‘ç¬¬äºŒä¸ª/ç”¨ç¬¬äºŒä¸ªè¦†ç›–
    // * ğŸš©å†è¯•ç¬¬äºŒä¸ª
    // * ğŸš©å°è¯•ä¸åˆ°å°±æ˜¯å°è¯•ä¸åˆ°
    // * ğŸš©æ ¹æ®ä¸­é—´æ¡ä»¶å¤šæ¬¡è¦†ç›–ï¼Œæœ€ç»ˆæ‹¿åˆ°ä¸€ä¸ªå¼•ç”¨
    todo!()
}

/// å› å˜é‡æ¶ˆå…ƒ
/// * ğŸ“ç”¨äºå¤„ç†ç±»ä¼¼ã€Œå­˜åœ¨å˜é‡ã€çš„æƒ…å†µ
///
/// # ğŸ“„OpenNARS
///
/// ```nal
/// {(&&, <#x() --> S>, <#x() --> P>), <M --> P>} |- <M --> S>
/// ```
pub fn eliminate_var_dep(
    compound: CompoundTermRef,
    component: &Term,
    compound_from: PremiseSource,
    context: &mut ReasonContextConcept,
) {
    // * ğŸš©æå–å‚æ•° * //
    // * ğŸš©è¯é¡¹ * //
    // * ğŸš©çœŸå€¼ * //
    // * ğŸš©å¤åˆè¯é¡¹æ¥è‡ªä»»åŠ¡ â‡’ ä»»åŠ¡ï¼Œä¿¡å¿µ
    // * ğŸš©å¦åˆ™ â‡’ ä¿¡å¿µï¼Œä»»åŠ¡
    // * ğŸš©é¢„ç®— * //
    // * ğŸš©å¤åˆè¯é¡¹æ¥è‡ªä»»åŠ¡ â‡’ åå‘
    // * ğŸš©å…¶å®ƒ â‡’ åå‘å¼±æ¨ç†
    // * ğŸš©å‰å‘æ¨ç†
    // * ğŸš©ç»“è®º * //
}
