//! ğŸ“„OpenNARS `nars.language.MakeTerm`
//! * ğŸ¯ç”¨äºã€Œåˆ¶ä½œè¯é¡¹ã€

use super::Term;

impl Term {
    /// åˆ¶ä½œã€Œè¯è¯­ã€
    pub fn make_word(name: impl Into<String>) -> Term {
        Term::new_word(name)
    }

    #[cfg(TODO)] // TODO: æœ‰å¾…å¤ç”¨
    /// ğŸ“„OpenNARS `Statement.makeSym`
    /// * ğŸš©é€šè¿‡ä½¿ç”¨ã€Œæ ‡è¯†ç¬¦æ˜ å°„ã€å°†ã€Œéå¯¹ç§°ç‰ˆæœ¬ã€æ˜ å°„åˆ°ã€Œå¯¹ç§°ç‰ˆæœ¬ã€
    /// * âš ï¸ç›®å‰åªæ”¯æŒã€Œç»§æ‰¿ã€å’Œã€Œè•´å«ã€ï¼Œå…¶å®ƒå‡ä¼š`panic`
    ///
    /// # ğŸ“„OpenNARS
    /// Make a symmetric Statement from given components and temporal information,
    /// called by the rules
    pub fn new_sym_statement(identifier: &str, subject: Term, predicate: Term) -> Self {
        match identifier {
            // ç»§æ‰¿â‡’ç›¸ä¼¼
            INHERITANCE_RELATION => Term::new_similarity(subject, predicate),
            // è•´å«â‡’ç­‰ä»·
            IMPLICATION_RELATION => Term::new_equivalence(subject, predicate),
            // å…¶å®ƒâ‡’panic
            _ => unimplemented!("ä¸æ”¯æŒçš„æ ‡è¯†ç¬¦ï¼š{identifier:?}"),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[cfg(TODO)] // TODO: æœ‰å¾…å¤ç”¨
    #[test]
    fn new_sym_statement() -> AResult {
        asserts! {
            // ç»§æ‰¿â‡’ç›¸ä¼¼
            Term::new_sym_statement(INHERITANCE_RELATION, term!("A"), term!("B"))
                => term!("<A <-> B>")
            // è•´å«â‡’ç­‰ä»·
            Term::new_sym_statement(IMPLICATION_RELATION, term!("A"), term!("B"))
                => term!("<A <=> B>")
        }
        ok!()
    }
}
